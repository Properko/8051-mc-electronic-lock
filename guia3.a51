#include <REG51F380.h>
$include(DISPLAY_LOOKUP.INC)

; define global variables
BLOCK_SIZE EQU 9

PB1 EQU P0.6
PB2 EQU P0.7

NUMBER_1 EQU R2
NUMBER_2 EQU R3
NUMBER_3 EQU R4
NUMBER_4 EQU R5

TIMEOUT EQU 02H

NOT_INITIALIZED EQU 0FFH

; we have a way of representing 16 numbers on the display (0-F)
NUMBER_COUNT EQU 10

; CALL INIT
CSEG	AT	0H
	LJMP	INIT
CSEG	AT	50H

INIT:
	MOV PCA0MD, #0
	; needed for using buttons and screen
	MOV XBR1, #40H
	SETB PB1
	SETB PB2
	
	LJMP MAIN
MAIN:
	MOV R0, #00H
	MOV R1, #00H

	JNB P3.6, NOT_RESET_TO_DEFAULT_KEY
	; --- reset to default key
	MOV NUMBER_1, #01H
	MOV NUMBER_2, #02H
	MOV NUMBER_3, #03H
	MOV NUMBER_4, #04H
	
	; --- set HW_FLAG to '0'
	CLR P3.6
	NOT_RESET_TO_DEFAULT_KEY:
		; --- encrypt and store key
		CALL SET_NUMBERS_TO_R6_R7
		CALL ENCRYPT_KEY

LOOP:
	CALL RESET_REGISTERS
	
	; --- display 'L'
	MOV R0, #0AH
	CALL DISPLAY_R0
	MOV R0, #00H

	; if PB1 is pushed => change number for selecting
	JNB PB1, SELECT_NUMBERS
	
	; if PB2 is pushed => set number
	JNB PB2, LOOP
	
	SJMP LOOP
	SELECT_NUMBERS:
		JNB PB1, $
		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
	
	CALL DECRYPT_KEY
    CALL COMPARE_PASSWORDS
	
	CALL ENCRYPT_KEY
	CALL RESET_REGISTERS
	
	CJNE A, #00H, INVALID
	MOV R0, #00H
	CALL DISPLAY_OVERFLOW
	
	VALID:
		MOV R2, #250D
		
		; --- increase TIMEOUT max 30 times
		DEC TIMEOUT
		MOV A, TIMEOUT
		CJNE A, #00H, LABEL_1
		
		TIME_OUT:
			MOV A, #00H
			MOV TIMEOUT, A

			CALL RESET_REGISTERS
			MOV B, #00H
			SJMP LOOP
		
		; --- start 1 second delay
		LABEL_1:
			DISPLAY_O:
				MOV R0, #0BH
				CALL DISPLAY_R0
				CALL DELAY_500_MS

				CJNE A, #0FFH, CHECK_IF_LOCK_STATE_1
				SJMP SET_NEW_PASSWORD
			CHECK_IF_LOCK_STATE_1:
				CJNE A, #00H, DISPLAY_EMPTY
				MOV B, #00H
				SJMP LOOP

			DISPLAY_EMPTY:
				MOV R0, #0EH
				CALL DISPLAY_R0
				CALL DELAY_500_MS

				CJNE A, #0FFH, CHECK_IF_LOCK_STATE_2
				SJMP SET_NEW_PASSWORD
			CHECK_IF_LOCK_STATE_2:
				CJNE A, #00H, VALID
				MOV B, #00H
				SJMP LOOP
		DELAY_1: 
			MOV R3,#250D
			MOV R4,#250D
		LOOP_1: DJNZ R3,LOOP_1
		LOOP_2: DJNZ R4,LOOP_2
				RET
	SET_NEW_PASSWORD:
		JNB PB1, $
		
		MOV R0, #00H
		MOV R1, #00H
		CALL RESET_REGISTERS

		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
		CALL SELECT_NUMBER
		
		; --- encrypt and store key
		CALL SET_NUMBERS_TO_R6_R7
		CALL ENCRYPT_KEY
		CALL RESET_REGISTERS
		
		MOV B, #00H
		LJMP LOOP
	INVALID:
		CALL INVALID_PASSWORD
		CALL RESET_REGISTERS
		LJMP LOOP

RESET_REGISTERS:
	MOV NUMBER_1, #NOT_INITIALIZED
	MOV NUMBER_2, #NOT_INITIALIZED
	MOV NUMBER_3, #NOT_INITIALIZED
	MOV NUMBER_4, #NOT_INITIALIZED
RET

COMPARE_PASSWORDS:
	; --- keep value fo counter
	MOV R1, B

	; --- valid first NUMBER_1, NUMBER_2
	MOV A, NUMBER_1
    MOV B, #010H
    MUL AB
    MOV R0, A
	
	MOV A, NUMBER_2
	ADD A, R0
	MOV R0, #00H
	
	XRL A, R6
	CJNE A, #00H, INVALID_KEY
	
	; --- valid first NUMBER_3, NUMBER_4
	MOV A, NUMBER_3
    MOV B, #010H
    MUL AB
    MOV R0, A
	
	MOV A, NUMBER_4
	ADD A, R0
	MOV R0, #00H
	
	XRL A, R7
	CJNE A, #00H, INVALID_KEY
	
	MOV B, R1
	RET
	
	INVALID_KEY:
		MOV B, R1
		RET
	
INVALID_PASSWORD:
	; --- display 'F'
	MOV R0, #0DH
	CALL DISPLAY_R0
	MOV R0, #00H
	
	INC B
	MOV R0, B
	CJNE R0, #05H, BLOCK_TIMEOUT
	ALERT:
		; --- display 'b'
		MOV R0, #0CH
		CALL DISPLAY_R0
		MOV R0, #00H
		CALL SQUARE_WAVE
	BLOCK_TIMEOUT:
		DELAY_COUNTER_TIMES:
			CALL DELAY_TIMEOUT_SEC
			DEC R0
			CJNE R0, #00H, DELAY_COUNTER_TIMES
		RET

SQUARE_WAVE:
	MOV P1,#00000000B
	MOV TMOD,#00000001B
	MAIN_SV: SETB P1.0
		  ACALL DELAY_SV
		  CLR P1.0
		  ACALL DELAY_SV
		  SJMP MAIN_SV
	DELAY_SV: MOV TH0,#0FEH
		   MOV TL0,#00CH
		   SETB TR0
	HERE_SV: JNB TF0,HERE_SV
		  CLR TR0
		  CLR TF0
		  SETB P1.0
		  RET

DELAY_500_MS:
	DELAY_500:
		MOV R2, #250D
	LABEL_500_MS:
		ACALL DELAY_500_tmp
		ACALL DELAY_500_tmp

		; if PB2 is pushed => LOAD
		JNB PB2, GO_TO_LOCK_STATE

		; if PB1 is pushed => SET new pass
		JNB PB1, SET_NEW_KEY

		DJNZ R2, LABEL_500_MS
		RET
	GO_TO_LOCK_STATE:
		JNB PB2, $
		MOV A, #00H
		RET
	SET_NEW_KEY:
		JNB PB1, $
		MOV A, #0FFH
		RET
	DELAY_500_tmp:
		MOV R3,#250D
		MOV R4,#250D
	LOOP1_500: DJNZ R3, LOOP1_500
	LOOP2_500: DJNZ R4, LOOP2_500
	RET

DELAY_1_SEC:
	DELAY1:
		MOV R2, #250D
	LABEL_1_SEC:
		ACALL DELAY
		ACALL DELAY
		ACALL DELAY
		ACALL DELAY
		DJNZ R2, LABEL_1_SEC
		RET
	DELAY: 
		MOV R3,#250D
		MOV R4,#250D
	LOOP1: DJNZ R3, LOOP1
	LOOP2: DJNZ R4, LOOP2
	RET

DELAY_TIMEOUT_SEC:
	MOV A, #TIMEOUT
	START_DELAY:
		DEC A
		CJNE A, #00H, CALL_1_SEC_DELAY

	CALL RESET_REGISTERS
	RET

	CALL_1_SEC_DELAY:
		CALL DELAY_1_SEC
		SJMP START_DELAY

SET_NUMBERS_TO_R6_R7:
	MOV A, NUMBER_1
    MOV B, #010H
    MUL AB
    MOV R6, A
	MOV A, NUMBER_2
	ADD A, R6
    MOV R6, A
	
	MOV A, NUMBER_3
    MOV B, #010H
    MUL AB
    MOV R7, A
	MOV A, NUMBER_4
	ADD A, R7
    MOV R7, A
RET
	
ENCRYPT_KEY:
    MOV A, R6
    XRL A, #0FFH
    MOV R6, A

    MOV A, R7
    XRL A, #0FFH
    MOV R7, A
RET

DECRYPT_KEY:
    MOV A, R6
    XRL A, #0FFH
	MOV R6, A
	
	MOV A, R7
    XRL A, #0FFH
	MOV R7, A
RET

SELECT_NUMBER:
	CALL DISPLAY_R0
	
	; if PB1 is pushed => change number for selecting
	JNB PB1, CHANGE_NUMBER
	
	; if PB2 is pushed => set number
	JNB PB2, SET_NUMBER
	
	SJMP SELECT_NUMBER
	CHANGE_NUMBER:
		JNB PB1, $
		INC R0
		
		; --- mod 10
		MOV R1, #NUMBER_COUNT
		CALL MOD_R0_R1
		
		SJMP SELECT_NUMBER
	SET_NUMBER:
		JNB PB2, $
		
		; if number_1 is alrady set, set number 2
		CJNE NUMBER_1, #NOT_INITIALIZED, SET_NUMBER2
		
		MOV A, R0
		MOV NUMBER_1, A
		MOV R0, #0
		RET

	SET_NUMBER2:
		; if number_2 is alrady set, set number 3
		CJNE NUMBER_2, #NOT_INITIALIZED, SET_NUMBER3
		
		MOV A, R0
		MOV NUMBER_2, A
		MOV R0, #0
		RET
		
	SET_NUMBER3:
		; if number_3 is alrady set, set number 4
		CJNE NUMBER_3, #NOT_INITIALIZED, SET_NUMBER4
		
		MOV A, R0
		MOV NUMBER_3, A
		MOV R0, #0
		RET

	SET_NUMBER4:
		MOV A, R0
		MOV NUMBER_4, A
		MOV R0, #0
		RET
RET

MOD_R0_R1:
	; --- keep counter
	MOV R2, B

	; --- modulus used by register R1
	MOV A, R0
	MOV B, R1
	DIV AB
	MOV R0, B

	MOV B, R2
	MOV R2, #NOT_INITIALIZED
RET

DISPLAY_R0:
	; --- display number/operator based on value in #TABLE
	MOV DPTR, #TABLE
	MOV A, R0
	MOVC A, @A+DPTR
	MOV P2, A
	MOV A, R0
RET

DISPLAY_OVERFLOW:
	; light up the (overflow) dot
	CLR P2.7
RET

END
